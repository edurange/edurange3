ScenarioTitle: Hello Edurange

# Define content sections with aliases
contentDefinitions:
  Reading1: &reading1
    type: reading
    content: |
      ### How to Connect
      Use the credentials and IP address provided on the scenario page to SSH into the exercise. SSH is an important network protocol that is used in most of our scenarios, so you need some minimal knowledge on how to use it on your OS.
  Reading2: &reading2
    type: reading
    content: |
      ## Using the Terminal Commands in the Unix shell
      
      When using your computer (Mac, Linux, Windows), you often need to interact with the operating system to access shared resources like disk storage or external hardware.
      
      - A “*shell*” is a program that allows you to interact with the OS in text mode, also called a “***c**ommand **l**ine **i**nterface*” or CLI.
      
      “***G**raphical **u**ser **i**nterfaces*” (GUI) are generally designed to simplify and expedite user interactions. However, they can sometimes restrict the user beyond that requirement. Text-based interfaces are more complex by comparison, but they allow more freedom.
      
      To get into the guts of your computer and really to control it we will learn how to use the command line.
      
      - The device and/or software that connects you to the command line can sometimes be called a “*terminal*”.
      - The software that provides the command line interface itself on the host computer is called the “*shell*” because it wraps around the operating system.
      
      #### bash and Other Shells
      In eduRange we use the “***B**ourne **A**gain **Sh**ell*”, “`bash`”.
      
      `bash` owes its name to one of the first shells, the “*Bourne **Sh**ell*” “`sh`”, originally by Bell Laboratories. `bash` was created by the GNU Project and Free Software Foundation as part of the open source movement.
      
      - There are other shells, though. Many common Unix-like operating systems come with more than one installed. When working outside of eduRange, remember that you may not always be presented with a `bash` shell by default.
      
      Shells and many other programs on the command line have different and alternative versions. It helps to check documentation when in doubt, because there are too many details to remember practically.
      
  Reading3: &reading3
    type: reading
    content: |
      ## man Pages and apropos
      
      “*`man` pages*" is short for “**man**ual” pages. These are text documents with lots of information on things installed on your system. “`man`” is a command for reading the `man` pages.
      
      Remember the command we did earlier, `ls`? Let's find that `man` page.
      
      Type:
      
      ```sh
      man ls
      ```
      
      To exit `man`, just type “`q`” to “***q**uit*”.
      
      
      Open the `man` page for `cp`. What option would provide verbose output? It’s worth noting that many commands provide an option with this name, not just `cp`.
      
      
      - `man` pages are an important resource because they are specific to the software actually installed on the system you’re currently using.
      - Some commands have different behavior depending on their version.
      - An online resource may or may not have information specific to your system, but `man` always contains documentation for what you have installed.
      
      There are even entirely different implementations of some programs - including shells, as mentioned earlier. When it comes to shell information remember to ask `man` about the right shell. In eduRange that will be `man bash`, but the default shell on your own systems might vary.
      
      ### man Page Key Points: SYNOPSIS and EXAMPLES
      
      For many commands, there’s an overwhelming amount of information in the `man` pages. The pages are divided up into sections.
      
      Most every `man` page includes two particularly useful sections:
      
      - A *synopsis* showing how the command is written in the format discussed earlier, and 
      - A series of *examples* showing exact instances of the command in particular uses.
      
      When in a `man` page, you can type a slash “`/`” to search for text.
      
      The headers are in all capitals, so after opening up a particular page, to search for the synopsis you’d type
      
      ```sh
      /SYNOPSIS
      ```
      
      and then hit enter.
      
      - `man` will highlight all instances of the text “`SYNOPSIS`”.
      - Typing “`n`” will bring you to the “**n**ext” search result.
      - “`b`” will take you “**b**ack”.
      - Remember, “`q`” to “**q**uit” when you’re done.
      
      Try searching for the “`EXAMPLES`” section in `man ls`.
      
      ```sh
      man ls
      /EXAMPLES
      ```
      ### apropos
      
      “`apropos`” searches all `man` pages for some given text - meaning “*to the purpose; fitly, opportunely*”, from “***aprop**riate*”.
      
      - It’s useful when you aren’t sure what commands are relevant to the term you’re looking for, or can’t remember the proper spelling.
      
      `apropos` is often a wrapper for `man -k`. If a system lacks `apropos`, it may still have `man -k`.
      
      `man` pages contain information about many topics, not just shell commands. `apropos` or `man -k` will return information on all `man` contents, including things you can’t do on the shell.
      
      To constrain `apropos` to just shell commands, use the option “`-s1`”. “`s`” is short for “**s**ection”. Pages on commands are contained in section one of `man`. You won’t need to refer to any other sections for this scenario.
      
      ```sh
      apropos rename
      ```

      Check the `man` pages to figure out which command is used to “rename” a file. You may need to search for examples (“`/EXAMPLES`” within `man`).
      
  Reading4: &reading4
    type: reading
    content: |
      # Unix Filesystems
      
      Unix folders and files are arranged in a tree structure, where the root node is the beginning of a path to any file in the entire file system.
      
      - The “*root node*” (or “*root directory*”) of the filesystem is written with the slash character “`/`”.
      - The leaves of the tree are the individual files.
      - This means that if you want to search the entire file system, you need to start at `/`.
      
      ```mermaid
      flowchart TD
      A["/"] --> B(/bin)
      A --> C(/home)
      C --> C1(/home/user1)
      C --> C2(/home/user2)
      C --> CElipsis(...)
      C --> CHomeDir(~ [aka you!])
      A --> D(/usr)
      D --> D1(/usr/bin)
      D --> DElipsis(...)
      A --> E(...)
      ```

      ### Exploring the Filesystem With ls

      Due to its tree structure, the locations of files stored in a filesystem are called paths.

      - A “*path*” can refer to both a file or a directory.

      When logging in, your shell session starts in a directory designated specifically to your account on that system. This directory - which belongs just to you - is called your “*home directory*”.

      As before, you can look around the filesystem by typing -

      ```sh
      ls
      ```

      and hitting enter. You should see something like this -

      ```sh
      [username]@[hostname]$ ls
      [example output]
      ```

      These are the contents of your home directory.
      - `ls` shows where the shell session is currently located within the filesystem, also called the “*current working directory*”.
      `ls` is short for “***l**i**s**t*” (files) and can display other parts of the filesystem as well.

      If you didn’t earlier, try -

      ```sh
      ls /
      ```
      
      - In this case, “`ls`” is the command you’re invoking, and 
      - “`/`” is a path.
      - The path is an argument that’s provided to the command when the shell invokes it.

      “`ls /`” shows the contents of the root directory “`/`”.

      `ls` doesn’t change anything, so you are free to look around the filesystem without worry. There will be some paths for which you don’t have permission to see, but `ls` can’t cause anything bad to happen.

      ### Naming Conventions

      - `/`, as mentioned earlier, might be called just “*root*” or more specifically the “*root node*” or “*root directory*”.
      - `/home` contains the “***home***” directories for all users, other than root. (On Mac OS, desktop users’ homes are in `/Users` instead.)
      - `/usr` contains common data for resources provided to all (particularly unprivileged) “***us**e**r**s*”, such as libraries and the files that `man` uses to deliver documentation. Many commands are stored here as well.
      - `/usr/bin` is where the “***bin**ary*” executables in `/usr` are stored specifically.
      - `/bin` also contains binary executables, but if you `ls /bin`, you’ll see th  Reading11: &reading11
              
      There are a number of other top-level directories related to system operation that are outside the scope of this first lesson. `/etc` stores shared data like configuration files; `/dev` and `/mnt` are related to how the operating system manages hardware.

      You won’t need to interact with these other areas today. For now be aware that they’re system critical and not to be changed casually.

      ### Navigation: Long and Complicated Paths

      Typing paths can be cumbersome. Shells provide shortcuts to help.

      A “`.`” (“*dot*”) is short for your “*current working directory*”. We’ll introduce how to move around the filesystem shortly. For now your current working directory will be the same as your home directory like we talked about earlier; that’s where you start when logging in.
      - If the current working directory is “`/foo/bar`” then “`./baz`” will become “`/foo/bar/baz`” when the shell interprets it.
      “`..`” (“*dot-dot*”) then is the parent directory of the current working directory.
      - If the current working directory is “`/foo/bar`” then “`./baz`” will become “`/foo/baz`” when the shell interprets it.
      - “`/..`” is one exception - `/` is the root of all nodes, including itself, so “`/..`” is interpreted as just “`/`”.
      - `.` and `..` only have these meanings when they are used as directory names by themselves:
      - “`/..foo`” means *“the file or directory called* ‘`..foo`’ *in our current location”*.
      - “`../foo`” means *“the file or directory called* ‘`foo`’ *in the parent directory of our current location.*”

      Another shortcut is “`~`” (“tilde”). Used by itself, `~` is interpreted as the path to your home directory (admittedly not that useful until you move out of that home directory).

      ### Tab Completion
      The shell also has an auto-completion feature. Modern auto-correct algorithms share common ancestors with shell “*tab completion*”.

      You can hit tab to complete a path on the command line. If the path you’ve typed is ambiguous and there’s more than one possible completion, the shell will prompt you with a list of possibilities. If there are a lot of possibilities the shell may warn you that it’s about to print a big list. You can add to your command input to narrow the available choices.

      Tab completion even works for other commands on many shells. Behavior varies according to the command and what arguments have been provided. If the shell doesn’t have a policy for a particular command it will fall back to trying to find paths for tab completion.

  Reading5: &reading5
    type: reading
    content: |
      ## root Has More Than One Meaning
      
      In a Unix system, control over the root directory (or root “node”) is protected by restricting it to a single user. Early systems engineers chose to call this user “`root`”, which became a convention. Because this user has control of the root node, and thus anything stored on the system at all, the root user became the de facto authority over most things security-related. (In Windows, this user is instead called “`administrator`” by default, but its role is similar.)
      
      With both the root user and root node being important vocabulary for system administration, you'll come across ambiguities sometimes.
      
      - The “root” (node), signified by just “`/`”, is the beginning of all the system's files.
      - But if you were to log in as (the) “`root`” (user), your home directory - where you can save files - would be the *folder* “`/root`”, not the *root node*, “`/`”.
      - `root`’s home directory “`/root`” is not to be confused with the formal *root directory* “`/`”, the beginning of the path to all the files, even though they both might be casually read as “root directory” aloud.
      
      It’s considerate to your coworkers to call “`/root`” “*slash-`root`*” or something like “*`root`’s home*”.
      
      - Reserve “*`root`*” to refer to the path “`/`” or the user “`root`” exclusively, specifying whether you mean a path or user when it isn’t obvious - this is generally how you can expect the terms to be used.
      
      ### About root Privileges and Security
      
      A root user is someone who has access to everything on the computer. They could even delete everything on the computer.
      
      When setting up your own systems, be aware of how the root user and privileges are configured and controlled. Some systems might not ask to set up credentials initially, leaving the password for root set to a default value after install.
      
      You won’t be using protected parts of the system in this exercise, but there are many security exploits related to them that you’ll likely encounter in the future.
  Reading6: &reading6
    type: reading
    content: |
      # Commands and Navigation - pwd, cd, ls
      
      What is a shell command?
      
      - Commands are executable programs that you can call from your command line terminal.
      
      A common place to find shell commands is the `/usr/bin` folder, but remember that some critical ones will be in `/bin` instead.
      
      There are quite a lot of commands, even on simple systems. The list would be impractically long but if you wanted to you could get a sense of all the commands available on your system with `apropos -s1 .` (or `man -k -s1 .`).
      
      Let's narrow it down to a few that you really need to get around the filesystem.
      
      ### pwd
      
      `pwd` stands for "***p**rint **w**orking **d**irectory*" - it will tell you where you are within the filesystem, your current working directory.
      
      Now type -
      
      ```sh
      pwd
      ```
      
      You should see something similar to `/home/<foo>` where “`foo`” is your username.
      
      To learn more type `man pwd`. (Remember, type `q` to exit when you're done with `man`.)
      
      ### cd
      
      “`cd`” stands for “***c**hange **d**irectory*”, meaning to navigate to a different folder. If you ever are lost in the filesystem, `cd` by itself will take you back to your home directory.
      
      Enter each of the following, one at a time. If you use `ls` after each, you’ll see that your working directory is changing:
      
      ```sh
      cd /
      cd /root
      cd
      cd ../
      ```
      
      - The first command sends you to the root of your entire file system.
      - The second command sends you to the root user's home directory, but notice that you don't have permissions to `cd` to that directory.
      - The third command sends you back to your home directory because no path was specified with the command.
      - The fourth command sends you backwards (up) a level (remember the `..` above).
      
      ### ls and File Access Control
      As mentioned before, “`ls`” “***l**i**s**ts*” files and directories.
      
      - We’ve already seen a little of what `ls` can do. But as we mentioned earlier, there are arguments and options you can give a command to change how it behaves.
      
      First make sure you’ve returned to your home directory -
      
      ```sh
      cd
      ```
      
      Try -
      
      ```sh
      ls -la
      ```
      
      That's a lot of info! What you see are all the files and directories in the directory (folder) where you are currently working, including files that were hidden before!
      
      There’s also a lot more information, so rather than a list of filenames, we get a whole table with one file per row and columns with additional information about each.
      
      
      - The first column is a string of characters indicating the type of file followed by its “*permissions*”, settings that determine who is allowed to use files and what operations can be done on them.
      - A `–` at the beginning means a regular file. `d` is a directory (folder). `l` is a link. The rest of the string is either `-` or `r`, `w`, and `x`.
      - `r` here stands for "read", `w` for "write" and `x` for "execute". `-` in the position of one of the letters means that type of permission is denied.
      - Permissions can be set based for the user owning the file, users in the group owning the file, or all other users, and so the permission string repeats each `rwx` position three times.
      - Even more can be done with permissions, but those details are not displayed by `ls`. We’ll discuss what permissions mean and how to control them below.
      - The second column is the number of links or sub-directories in the directory, if this file is a directory. (In Unix, we tend to think of all things as files; even directories are just a special type of file.)
      - The third column is the user that owns the file.
      - The fourth is the group that owns the file.
      - The fifth is the size of the file.
      - The sixth is the date and time it was last edited.
      - And finally, the file name in the seventh column, on the far right.
      
      Type -
      
      ```sh
      man ls
      ```
      and hit enter.
      
      When we wrote `ls -la`, “`-la`” was a collection of *options*, sometimes also called “flags” informally.
      
      Recall -
      - Options are prefixed by a hyphen “`-`” and are used to instruct a command to provide extra or alternative behavior.
      - Options are specified by a single letter and are usually case sensitive.
      - Options like this can be combined without spaces, as with the “`-la`” we used.
      
      Let's learn what “`l`” and “`a`” mean.
      ### Locate Option "-l"
      Remember that to search inside a `man` page, you can use “`/`”.
      
      Type -
      
      ```sh
      /-l
      ```
      and hit enter.
      - You should see the page move to the first occurrence of “`-l`” found and that “`-l`” is highlighted.
      - You can jump to the next matching result by hitting “`n`” (for “***n**ext*”).
      
      Press “`n`” until you see “`-l`” highlighted at the beginning of the line; this is where the option is defined and will be above the line for “`-L`”.
      
      The “***l**ong*” listing option shows results with details in columns as seen in the earlier exercise.
      
      ### Locate Option "-a"
      Type -
      ```sh
      /-a
      ```
      and hit enter.
      - Hit “`n`” till you can't go any further.
      - Now hit “`b`” (which stands for “***b**ack*”) until you find the entry for “`-a`” (which is above “`-A`”).
      - The explanation on the `man` page might be a little terse.
      
      Remember when we mentioned that files can be hidden? By default, `ls` ignores file names that start with `.`.
      - The “***a**ll*” option specifies that hidden files, which start with `.` like `.profile`, ((insert a specific reference)) should be displayed.
      
      Hidden files aren’t hidden in the “secret” sense as much as they are just “*hidden from view*” to reduce visual clutter. Hidden files are often used to store configuration and other information that might repeat in many places and would be distracting if it showed up all the time.

      ### Globbing With ls
      
      If there are a lot of files in a directory, it can be useful to restrict what `ls` looks at to a subset of those files. The shell allows you to do that with paths that describe a pattern. This is called “*globbing*”. For example, if you are only interested in files with the extension “`.jpg`”, you can use:
      
      ```sh
      ls *.jpg
      ```
      
      The “`*`” “star” is a special character called a “*wildcard*”. Wildcards represent a part of the pattern that could vary. `*` specifically means that any substring could occur in that position of the *glob pattern*.    
      
      So the “`*.jpg`” means any string followed by “`.jpg`”, including just “`.jpg`” by itself - the empty string is still a string, so it satisfies the pattern.
      
      We’ll discuss and use *globs* more later on.
      
      Use `ls -la` on ((choose a path)) and look at the files inside. Which file is both hidden and larger than 1KB in size?
      
  Reading7: &reading7
    type: reading
    content: |
      # Commands: mv, cp, and mkdir
      ### mv
  
      You can use `mv` to move the filename and not just the directory it’s in, so there is no separate command to “rename” a file - renaming is the same as `mv`ing it from one name to another in the same directory.
                
      ### cp
                
      `cp` is used to “***c**o**p**y*” a file to a new location.
                
      ### mkdir
                
      `mkdir` is short for “***m**a**k**e **dir**ectory*” and does just what you’d think.
  
  Reading8: &reading8
    type: reading
    content: |
      ## chmod and sudo
              
      `chmod` comes from “***ch**ange **mod**e*” and alters the *permissions* of files and directories.
              
      - “*Permissions*”, mentioned earlier with regard to `ls -l`, are the settings on each file which determine who can use that file and how.
              
      `chmod` can be used in many ways so it takes a little more explaining than earlier commands.
              
      Files all have sets of permissions for three categories - the owner of the file (a user), the group the file belongs to (a collection of users), and all users not included by the first two categories.
              
      For each category, members of that category may or may not be allowed to read, write or execute the file. Thus, as we said before, there are three sets of three permission “bits” representing each combination of category and file operation.
              
      If you look at `man chmod` you’ll see that `chmod` accepts several different types of input, and has a lot more features than just the basic nine permissions. The essential points are:
              
      - `chmod` takes a mode and a file: `chmod mode file`
      - “`file`” is a path to the file you’d like to change (directories are files too)
      - “`mode`” can be written a number of ways; we’ll use “*symbolic mode*” here but you’ll likely see “*absolute mode*” (a numeric representation) in older examples
              
      *Symbolic* permission modes have a lot of shortcuts associated with them but we’ll focus on the basics here.
              
      - The mode should begin with any combination of “`u`” for user, “`g`” for group and “`o`” for other
      - Then follows an operator (just one): equals “`=`” assigns precisely the following permissions to the user/group/other category, plus “`+`” adds permissions, and minus “`-`” takes them away
      - Then follows a combination of “`r`” for read, “`w`” for write, and “`x`” for execute
              
      Some example uses -
              
      ```sh
      chmod g=r foo
      ```
              
      sets the permissions on “`foo`” to read-only for groups.
              
      ```sh
      chmod u=rwx foo
      ```
      
      sets the permissions on “`foo`” to read, write and execute for the owner.
      
      ```sh
      chmod o-wx foo
      ```
      
      removes write and execute permissions for others on “`foo`”, if it had write or execute permissions before.
      
      ```sh
      chmod ugo+r
      ```
      
      adds read permissions to “`foo`” for all categories if they didn’t have them before.
      
      You can further combine symbolic mode statements with commas, and there are more functions we won’t discuss here. They’re described under “`MODES`” in the `man` page.
      
      In actuality, most modern Unixes support even more customizable permissions than the choices above, but we’ll focus on the main permission modes in our exercises.
      
      ### `sudo`
      
      Access to some commands and files may need to be restricted, but as we said logging in as `root` gives the user permissions to do anything. The way to manage this safely is with “`sudo`” (which stands for “**s**ubstitute **u**ser **do**”.
      
      - `sudo` can be used to run commands as any other user, but in practice it’s mostly useful for accessing privileged commands. The use of `sudo` is usually restricted to a small number of users referred to as “*superusers*”.
      
      You may also come across the related command “`su`”, which changes the user identity and privileges of the current shell, whereas `sudo` runs the commands given as input and then returns to the normal shell environment.
  
  Reading9: &reading9
    type: reading
    content: |
      # Find and File
  
  Reading10: &reading10
    type: reading
    content: |
      # File Manipulation: cat, echo, touch, md5sum
  
  Reading11: &reading11
    type: reading
    content: |
      # Pagers and editors: less, more, tail, nano, pico, vim, emacs
  
  Reading12: &reading12
    type: reading
    content: |
      # Redirections, Filters, and Command Composition
  
  Question1: &question1
    question_num: 1
    type: question
    content: How many subdirectories are in your home directory? (Not including hidden directories)
    options: []
    answers:
      - value: "7"
        answer_type: String
        points_possible: 15
    points_possible: 15
  Question2: &question2
    question_num: 2
    type: question
    content: In your home directory there is subdirectory named followMe. Travel into the directory as far as you can go. At the end there is a file. What is the name of the file?
    options: []
    answers:
      - value: "$RANDOM"
        answer_type: String
        points_possible: 15
    points_possible: 15
  Question3: &question3
    question_num: 3
    type: question
    content: What does the line below NAME on the man page for the "file" command say?
    options: []
    answers:
      - value: file — determine file type
        answer_type: String
        points_possible: 15
      - value: file - determine file type
        answer_type: String
        points_possible: 15
  Question4: &question4
    question_num: 4
    type: question
    content: What is the secret code in the text file in the stuff directory? (If you try and read a non-ASCII text file, something WILL break!!)
    options: []
    answers:
      - value: "$RANDOM"
        answer_type: String
        points_possible: 15
    points_possible: 15
  Question5: &question5
    question_num: 5
    type: question
    content: What command or list of commands did you use to create a file with the contents of the three files in the textfiles directory? (Endless approaches, this question will not be graded automatically)
    options: []
    answers:
      - value: ""
        answer_type: Essay
        points_possible: 15
    points_possible: 15
  Question6: &question6
    question_num: 6
    type: question
    content: What are the filenames (with extensions) of the six image files hidden in your home directory that contain edurange in the name? Please enter the filesnames as a comma separated list, e.g. ("file1.jpg, file2.png, file3.gif").
    options: []
    answers:
      - value: edurange5meow.JPG
        answer_type: String
        points_possible: 3
      - value: edurange001.gif
        answer_type: String
        points_possible: 3
      - value: 4edurange.jpeg
        answer_type: String
        points_possible: 3
      - value: edurange006weeeeeee.png
        answer_type: String
        points_possible: 3
      - value: 002edurange.jpg
        answer_type: String
        points_possible: 3
      - value: edurange3.GIF
        answer_type: String
        points_possible: 3
    points_possible: 18
  Question7: &question7
    question_num: 7
    type: question
    content: What is the absolute path of the directory containing the file that has 'cowFJS' in its name? (Just the path to the directory, no filename)
    options: []
    answers:
      - value: "/usr/special/secrets/"
        answer_type: String
        points_possible: 20
    points_possible: 20

# Order of content using aliases
studentGuide:
  chapters:
    - chapter_num: 1
      title: Welcome to Cybersec
      content_array:
        - *reading1
        - *reading2
    - chapter_num: 2
      title: Questions
      content_array:
        - *question1
        - *question2
        - *question3
        - *question4
        - *question5
        - *question6
        - *question7
    - chapter_num: 3
      title: Man Pages
      content_array:
        - *reading3
        - *question1
    - chapter_num: 4
      title: Filesystem
      content_array:
        - *reading4
        - *reading5
    - chapter_num: 5
      title: Commands and Navigation
      content_array:
        - *reading6
        - *reading7
    - chapter_num: 6
      title: Permissions (chmod and sudo)
      content_array:
        - *reading8
    - chapter_num: 7
      title: Find and File
      content_array:
        - *reading9
    - chapter_num: 8
      title: File Manipulation
      content_array:
        - *reading10
    - chapter_num: 9
      title: Pages
      content_array:
        - *reading11
    - chapter_num: 10
      title: Redirection
      content_array:
        - *reading12
