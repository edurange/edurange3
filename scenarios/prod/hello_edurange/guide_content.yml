ScenarioTitle: Hello Edurange

# Define content sections with aliases
contentDefinitions:
  Reading1: &reading1
    type: reading
    content: |
      ### How to Connect
      Use the credentials and IP address provided in the bottom left of this 
      scenario page to SSH into the exercise. 
      
      SSH is an important network protocol that is used in most of our 
      scenarios, so you need some minimal knowledge on how to use it on your OS.
      
      If you need a backup, you can use the WebSSH button also in the bottom 
      left, but it is missing many convenience features provided by more 
      standard terminals.
  Reading2: &reading2
    type: reading
    content: |
      ## Using the Terminal Commands in the Unix shell
      
      When using your computer (Mac, Linux, Windows), you often need to interact
      with the operating system to access shared resources like disk storage 
      or external hardware.
      
      - A “*shell*” is a program that allows you to interact with the OS in text mode, also called a “***c**ommand **l**ine **i**nterface*” or CLI.
      
      “***G**raphical **u**ser **i**nterfaces*” (GUI) are generally designed to simplify and expedite user interactions. However, they can sometimes restrict the user beyond that requirement. Text-based interfaces are more complex by comparison, but they allow more freedom.
      
      To get into the guts of your computer and really to control it we will learn how to use the command line.
      
      - The device and/or software that connects you to the command line can sometimes be called a “*terminal*”.
      - The software that provides the command line interface itself on the host computer is called the “*shell*” because it wraps around the operating system.
     
      #### bash and Other Shells
      In eduRange we use the “***B**ourne **A**gain **Sh**ell*”, “`bash`”.
      
      `bash` owes its name to one of the first shells, the “*Bourne **Sh**ell*” “`sh`”, originally by Bell Laboratories. `bash` was created by the GNU Project and Free Software Foundation as part of the open source movement.
      
      - There are other shells, though. Many common Unix-like operating systems come with more than one installed. When working outside of eduRange, remember that you may not always be presented with a `bash` shell by default.
      
      Shells and many other programs on the command line have different and alternative versions. It helps to check documentation when in doubt, because there are too many details to remember practically.
      
  Reading13: &reading13
    type: reading
    content: |
      ## man Pages and apropos
      
      “*`man` pages*" is short for “**man**ual” pages. These are text documents with lots of information on things installed on your system. “`man`” is a command for reading the `man` pages.
      
      Remember the command we did earlier, `ls`? Let's find that `man` page.
      
      Type:
      
      ```sh
      man ls
      ```
      
      To exit `man`, just type “`q`” to “***q**uit*”.
      
      
  Reading3: &reading3
    type: reading
    content: |      
      - `man` pages are an important resource because they are specific to the software actually installed on the system you’re currently using.
      - Some commands have different behavior depending on their version.
      - An online resource may or may not have information specific to your system, but `man` always contains documentation for what you have installed.
      
      There are even entirely different implementations of some programs - including shells, as mentioned earlier. When it comes to shell information remember to ask `man` about the right shell. In eduRange that will be `man bash`, but the default shell on your own systems might vary.
      
      ### man Page Key Points: SYNOPSIS and EXAMPLES
      
      For many commands, there’s an overwhelming amount of information in the `man` pages. The pages are divided up into sections.
      
      Most every `man` page includes two particularly useful sections:
      
      - A *synopsis* showing how the command is written in the format discussed earlier, and 
      - A series of *examples* showing exact instances of the command in particular uses.
      
      When in a `man` page, you can type a slash “`/`” to search for text.
      
      The headers are in all capitals, so after opening up a particular page, to search for the synopsis you’d type
      
      ```sh
      /SYNOPSIS
      ```
      
      and then hit enter.
      
      - `man` will highlight all instances of the text “`SYNOPSIS`”.
      - Typing “`n`” will bring you to the “**n**ext” search result.
      - “`b`” will take you “**b**ack”.
      - Remember, “`q`” to “**q**uit” when you’re done.
      
      Try searching for the “`EXAMPLES`” section in `man ls`.
      
      ```sh
      man ls
      /EXAMPLES
      ```
      ### apropos
      
      “`apropos`” searches all `man` pages for some given text - meaning “*to the purpose; fitly, opportunely*”, from “***aprop**riate*”.
      
      - It’s useful when you aren’t sure what commands are relevant to the term you’re looking for, or can’t remember the proper spelling.
      
      `apropos` is often a wrapper for `man -k`. If a system lacks `apropos`, it may still have `man -k`.
      
      `man` pages contain information about many topics, not just shell commands. `apropos` or `man -k` will return information on all `man` contents, including things you can’t do on the shell.
      
      To constrain `apropos` to just shell commands, use the option “`-s1`”. “`s`” is short for “**s**ection”. Pages on commands are contained in section one of `man`. You won’t need to refer to any other sections for this scenario.
      
      ```sh
      apropos rename
      ```

      Check the `man` pages to figure out which command is used to “rename” a file. You may need to search for examples (“`/EXAMPLES`” within `man`).
      
  Reading4: &reading4
    type: reading
    content: |
      # Unix Filesystems
      
      Unix folders and files are arranged in a tree structure, where the root node is the beginning of a path to any file in the entire file system.
      
      - The “*root node*” (or “*root directory*”) of the filesystem is written with the slash character “`/`”.
      - The leaves of the tree are the individual files.
      - This means that if you want to search the entire file system, you need to start at `/`.
      
      ```mermaid
      flowchart TD
      A["/"] --> B(/bin)
      A --> C(/home)
      C --> C1(/home/user1)
      C --> C2(/home/user2)
      C --> CElipsis(...)
      C --> CHomeDir(~ [aka you!])
      A --> D(/usr)
      D --> D1(/usr/bin)
      D --> DElipsis(...)
      A --> E(...)
      ```

      ### Exploring the Filesystem With ls

      Due to its tree structure, the locations of files stored in a filesystem are called paths.

      - A “*path*” can refer to both a file or a directory.

      When logging in, your shell session starts in a directory designated specifically to your account on that system. This directory - which belongs just to you - is called your “*home directory*”.

      As before, you can look around the filesystem by typing -

      ```sh
      ls
      ```

      and hitting enter. You should see something like this -

      ```sh
      [username]@[hostname]$ ls
      [example output]
      ```

      These are the contents of your home directory.
      - `ls` shows where the shell session is currently located within the filesystem, also called the “*current working directory*”.
      `ls` is short for “***l**i**s**t*” (files) and can display other parts of the filesystem as well.

  Reading14: &reading14
    type: reading
    content: |

      If you didn’t earlier, try -

      ```sh
      ls /
      ```
      
      - In this case, “`ls`” is the command you’re invoking, and 
      - “`/`” is a path.
      - The path is an argument that’s provided to the command when the shell invokes it.

      “`ls /`” shows the contents of the root directory “`/`”.

      `ls` doesn’t change anything, so you are free to look around the filesystem without worry. There will be some paths for which you don’t have permission to see, but `ls` can’t cause anything bad to happen.

  
  Reading15: &reading15
    type: reading
    content: |
      ### Naming Conventions   
      - `/`, as mentioned earlier, might be called just “*root*” or more specifically the “*root node*” or “*root directory*”.
      - `/home` contains the “***home***” directories for all users, other than root. (On Mac OS, desktop users’ homes are in `/Users` instead.)
      - `/usr` contains common data for resources provided to all (particularly unprivileged) “***us**e**r**s*”, such as libraries and the files that `man` uses to deliver documentation. Many commands are stored here as well.
      - `/usr/bin` is where the “***bin**ary*” executables in `/usr` are stored specifically.
      - `/bin` also contains binary executables, but if you `ls /bin`, you’ll see th  Reading11: &reading11
              
      There are a number of other top-level directories related to system operation that are outside the scope of this first lesson. `/etc` stores shared data like configuration files; `/dev` and `/mnt` are related to how the operating system manages hardware.

      You won’t need to interact with these other areas today. For now be aware that they’re system critical and not to be changed casually.

      ### Navigation: Long and Complicated Paths

      Typing paths can be cumbersome. Shells provide shortcuts to help.

      A “`.`” (“*dot*”) is short for your “*current working directory*”. We’ll introduce how to move around the filesystem shortly. For now your current working directory will be the same as your home directory like we talked about earlier; that’s where you start when logging in.
      - If the current working directory is “`/foo/bar`” then “`./baz`” will become “`/foo/bar/baz`” when the shell interprets it.
      “`..`” (“*dot-dot*”) then is the parent directory of the current working directory.
      - If the current working directory is “`/foo/bar`” then “`./baz`” will become “`/foo/baz`” when the shell interprets it.
      - “`/..`” is one exception - `/` is the root of all nodes, including itself, so “`/..`” is interpreted as just “`/`”.
      - `.` and `..` only have these meanings when they are used as directory names by themselves:
      - “`/..foo`” means *“the file or directory called* ‘`..foo`’ *in our current location”*.
      - “`../foo`” means *“the file or directory called* ‘`foo`’ *in the parent directory of our current location.*”

      Another shortcut is “`~`” (“tilde”). Used by itself, `~` is interpreted as the path to your home directory (admittedly not that useful until you move out of that home directory).

      ### Tab Completion
      The shell also has an auto-completion feature. Modern auto-correct algorithms share common ancestors with shell “*tab completion*”.

      You can hit tab to complete a path on the command line. If the path you’ve typed is ambiguous and there’s more than one possible completion, the shell will prompt you with a list of possibilities. If there are a lot of possibilities the shell may warn you that it’s about to print a big list. You can add to your command input to narrow the available choices.

      Tab completion even works for other commands on many shells. Behavior varies according to the command and what arguments have been provided. If the shell doesn’t have a policy for a particular command it will fall back to trying to find paths for tab completion.

  Reading5: &reading5
    type: reading
    content: |
      ## root Has More Than One Meaning
      
      In a Unix system, control over the root directory (or root “node”) is protected by restricting it to a single user. Early systems engineers chose to call this user “`root`”, which became a convention. Because this user has control of the root node, and thus anything stored on the system at all, the root user became the de facto authority over most things security-related. (In Windows, this user is instead called “`administrator`” by default, but its role is similar.)
      
      With both the root user and root node being important vocabulary for system administration, you'll come across ambiguities sometimes.
      
      - The “root” (node), signified by just “`/`”, is the beginning of all the system's files.
      - But if you were to log in as (the) “`root`” (user), your home directory - where you can save files - would be the *folder* “`/root`”, not the *root node*, “`/`”.
      - `root`’s home directory “`/root`” is not to be confused with the formal *root directory* “`/`”, the beginning of the path to all the files, even though they both might be casually read as “root directory” aloud.
      
      It’s considerate to your coworkers to call “`/root`” “*slash-`root`*” or something like “*`root`’s home*”.
      
      - Reserve “*`root`*” to refer to the path “`/`” or the user “`root`” exclusively, specifying whether you mean a path or user when it isn’t obvious - this is generally how you can expect the terms to be used.
      
      ### About root Privileges and Security
      
      A root user is someone who has access to everything on the computer. They could even delete everything on the computer.
      
      When setting up your own systems, be aware of how the root user and privileges are configured and controlled. Some systems might not ask to set up credentials initially, leaving the password for root set to a default value after install.
      
      You won’t be using protected parts of the system in this exercise, but there are many security exploits related to them that you’ll likely encounter in the future.
  Reading6: &reading6
    type: reading
    content: |
      # Commands and Navigation - pwd, cd, ls
      
      What is a shell command?
      
      - Commands are executable programs that you can call from your command line terminal.
      
      A common place to find shell commands is the `/usr/bin` folder, but remember that some critical ones will be in `/bin` instead.
      
      There are quite a lot of commands, even on simple systems. The list would be impractically long but if you wanted to you could get a sense of all the commands available on your system with `apropos -s1 .` (or `man -k -s1 .`).
      
      Let's narrow it down to a few that you really need to get around the filesystem.
      
      ### pwd
      
      `pwd` stands for "***p**rint **w**orking **d**irectory*" - it will tell you where you are within the filesystem, your current working directory.
      
      Now type -
      
      ```sh
      pwd
      ```
      
      You should see something similar to `/home/<foo>` where “`foo`” is your username.
      
      To learn more type `man pwd`. (Remember, type `q` to exit when you're done with `man`.)
      
      ### cd
      
      “`cd`” stands for “***c**hange **d**irectory*”, meaning to navigate to a different folder. If you ever are lost in the filesystem, `cd` by itself will take you back to your home directory.
      
      Enter each of the following, one at a time. If you use `ls` after each, you’ll see that your working directory is changing:
      
      ```sh
      cd /
      cd /root
      cd
      cd ../
      ```
      
      - The first command sends you to the root of your entire file system.
      - The second command sends you to the root user's home directory, but notice that you don't have permissions to `cd` to that directory.
      - The third command sends you back to your home directory because no path was specified with the command.
      - The fourth command sends you backwards (up) a level (remember the `..` above).
      
      ### ls and File Access Control
      As mentioned before, “`ls`” “***l**i**s**ts*” files and directories.
      
      - We’ve already seen a little of what `ls` can do. But as we mentioned earlier, there are arguments and options you can give a command to change how it behaves.
      
      First make sure you’ve returned to your home directory -
      
      ```sh
      cd
      ```
      
      Try -
      
      ```sh
      ls -la
      ```
      
      That's a lot of info! What you see are all the files and directories in the directory (folder) where you are currently working, including files that were hidden before!
      
      There’s also a lot more information, so rather than a list of filenames, we get a whole table with one file per row and columns with additional information about each.
      
      
      - The first column is a string of characters indicating the type of file followed by its “*permissions*”, settings that determine who is allowed to use files and what operations can be done on them.
      - A `–` at the beginning means a regular file. `d` is a directory (folder). `l` is a link. The rest of the string is either `-` or `r`, `w`, and `x`.
      - `r` here stands for "read", `w` for "write" and `x` for "execute". `-` in the position of one of the letters means that type of permission is denied.
      - Permissions can be set based for the user owning the file, users in the group owning the file, or all other users, and so the permission string repeats each `rwx` position three times.
      - Even more can be done with permissions, but those details are not displayed by `ls`. We’ll discuss what permissions mean and how to control them below.
      - The second column is the number of links or sub-directories in the directory, if this file is a directory. (In Unix, we tend to think of all things as files; even directories are just a special type of file.)
      - The third column is the user that owns the file.
      - The fourth is the group that owns the file.
      - The fifth is the size of the file.
      - The sixth is the date and time it was last edited.
      - And finally, the file name in the seventh column, on the far right.
      
      Type -
      
      ```sh
      man ls
      ```
      and hit enter.
      
      When we wrote `ls -la`, “`-la`” was a collection of *options*, sometimes also called “flags” informally.
      
      Recall -
      - Options are prefixed by a hyphen “`-`” and are used to instruct a command to provide extra or alternative behavior.
      - Options are specified by a single letter and are usually case sensitive.
      - Options like this can be combined without spaces, as with the “`-la`” we used.
      
      Let's learn what “`l`” and “`a`” mean.
      ### Locate Option "-l"
      Remember that to search inside a `man` page, you can use “`/`”.
      
      Type -
      
      ```sh
      /-l
      ```
      and hit enter.
      - You should see the page move to the first occurrence of “`-l`” found and that “`-l`” is highlighted.
      - You can jump to the next matching result by hitting “`n`” (for “***n**ext*”).
      
      Press “`n`” until you see “`-l`” highlighted at the beginning of the line; this is where the option is defined and will be above the line for “`-L`”.
      
      The “***l**ong*” listing option shows results with details in columns as seen in the earlier exercise.
      
      ### Locate Option "-a"
      Type -
      ```sh
      /-a
      ```
      and hit enter.
      - Hit “`n`” till you can't go any further.
      - Now hit “`b`” (which stands for “***b**ack*”) until you find the entry for “`-a`” (which is above “`-A`”).
      - The explanation on the `man` page might be a little terse.
      
      Remember when we mentioned that files can be hidden? By default, `ls` ignores file names that start with `.`.
      - The “***a**ll*” option specifies that hidden files, which start with `.` like `.profile`, ((insert a specific reference)) should be displayed.
      
      Hidden files aren’t hidden in the “secret” sense as much as they are just “*hidden from view*” to reduce visual clutter. Hidden files are often used to store configuration and other information that might repeat in many places and would be distracting if it showed up all the time.

      ### Globbing With ls
      
      If there are a lot of files in a directory, it can be useful to restrict what `ls` looks at to a subset of those files. The shell allows you to do that with paths that describe a pattern. This is called “*globbing*”. For example, if you are only interested in files with the extension “`.jpg`”, you can use:
      
      ```sh
      ls *.jpg
      ```
      
      The “`*`” “star” is a special character called a “*wildcard*”. Wildcards represent a part of the pattern that could vary. `*` specifically means that any substring could occur in that position of the *glob pattern*.    
      
      So the “`*.jpg`” means any string followed by “`.jpg`”, including just “`.jpg`” by itself - the empty string is still a string, so it satisfies the pattern.
      
      We’ll discuss and use *globs* more later on.
      
      Check in questions:
      
  Reading7: &reading7
    type: reading
    content: |
      # Commands: mv, cp, and mkdir
      ### mv
  
      You can use `mv` to move the filename and not just the directory it’s in, so there is no separate command to “rename” a file - renaming is the same as `mv`ing it from one name to another in the same directory.
                
      ### cp
                
      `cp` is used to “***c**o**p**y*” a file to a new location.
                
      ### mkdir
                
      `mkdir` is short for “***m**a**k**e **dir**ectory*” and does just what you’d think.
  
  Reading8: &reading8
    type: reading
    content: |
      ## chmod and sudo
              
      `chmod` comes from “***ch**ange **mod**e*” and alters the *permissions* of files and directories.
              
      - “*Permissions*”, mentioned earlier with regard to `ls -l`, are the settings on each file which determine who can use that file and how.
              
      `chmod` can be used in many ways so it takes a little more explaining than earlier commands.
              
      Files all have sets of permissions for three categories - the owner of the file (a user), the group the file belongs to (a collection of users), and all users not included by the first two categories.
              
      For each category, members of that category may or may not be allowed to read, write or execute the file. Thus, as we said before, there are three sets of three permission “bits” representing each combination of category and file operation.
              
      If you look at `man chmod` you’ll see that `chmod` accepts several different types of input, and has a lot more features than just the basic nine permissions. The essential points are:
              
      - `chmod` takes a mode and a file: `chmod mode file`
      - “`file`” is a path to the file you’d like to change (directories are files too)
      - “`mode`” can be written a number of ways; we’ll use “*symbolic mode*” here but you’ll likely see “*absolute mode*” (a numeric representation) in older examples
              
      *Symbolic* permission modes have a lot of shortcuts associated with them but we’ll focus on the basics here.
              
      - The mode should begin with any combination of “`u`” for user, “`g`” for group and “`o`” for other
      - Then follows an operator (just one): equals “`=`” assigns precisely the following permissions to the user/group/other category, plus “`+`” adds permissions, and minus “`-`” takes them away
      - Then follows a combination of “`r`” for read, “`w`” for write, and “`x`” for execute
              
      Some example uses -
              
      ```sh
      chmod g=r foo
      ```
              
      sets the permissions on “`foo`” to read-only for groups.
              
      ```sh
      chmod u=rwx foo
      ```
      
      sets the permissions on “`foo`” to read, write and execute for the owner.
      
      ```sh
      chmod o-wx foo
      ```
      
      removes write and execute permissions for others on “`foo`”, if it had write or execute permissions before.
      
      ```sh
      chmod ugo+r
      ```
      
      adds read permissions to “`foo`” for all categories if they didn’t have them before.
      
      You can further combine symbolic mode statements with commas, and there are more functions we won’t discuss here. They’re described under “`MODES`” in the `man` page.
      
      In actuality, most modern Unixes support even more customizable permissions than the choices above, but we’ll focus on the main permission modes in our exercises.
      
      ### `sudo`
      
      Access to some commands and files may need to be restricted, but as we said logging in as `root` gives the user permissions to do anything. The way to manage this safely is with “`sudo`” (which stands for “**s**ubstitute **u**ser **do**”.
      
      - `sudo` can be used to run commands as any other user, but in practice it’s mostly useful for accessing privileged commands. The use of `sudo` is usually restricted to a small number of users referred to as “*superusers*”.
      
      You may also come across the related command “`su`”, which changes the user identity and privileges of the current shell, whereas `sudo` runs the commands given as input and then returns to the normal shell environment.
  
  Reading9: &reading9
    type: reading
    content: |
      ### Background: File Types

      Not all files appear as they really are. Just because you see a file named “`foo.png`” does not mean that there is PNG image data inside. It could be a text file hiding a secret message, or contain harmful executable code, or have been named by mistake.

      - File extensions are a convention for keeping things organized - not an enforced rule or a promise about what the file actually is. Whoever creates the file chooses its name and extension, however they like.

      So, how can you get more information on what a file actually contains? One way is with the “`file`” command!

      ### `file`

      To find out what a **file** really is regardless of its extension, you could examine the byte data inside, but `file` can often do this for us automatically.

      There are two files in a directory called “`toLearn`” within your home. One is called “`cat.jpg`” and the other is “`dog.jpg`”

      Both look like JPEG images, right? But using `ls -l` you can see that one is a lot larger in size than the other - over a thousand times larger! One is about 25,000 bytes whereas the other is only about 20. Let's find out what’s really going on.

      
      In the toLearn directory, type:

      ```sh
      file dog.jpg
      ```

      You'll see something like:

      ```sh
      [username]@[hostname]$ file dog.jpg
      dog.jpg: ASCII text
      ```

      Now type:

      ```sh
      file cat.jpg
      ```

      You'll see something like:

      ```sh
      [username]@[hostname]$ file cat.jpg
      cat.jpg: JPEG image data, Exif standard: TIFF image data, ... etc.
      ```

      `file` tells you about the format of a file, and can sometimes even identify the data encodings used within that format.

      Incidentally, some file extensions can refer to the same file type. For instance, JPEG files may appear with a `.jpg` suffix as well as `.jpeg`. At one time, some operating systems had limits on the length of file extensions, but today most systems recognize both long and short file extensions.
  Reading16: &reading16
    type: reading
    content: |
      ### `find`

      “`find`” does just what it sounds like - helps you “***find***” files on the filesystem. `find` takes different qualities that define what you’re looking for, and does the repetitive work of searching each directory in the tree work for you.

      An example:

      ```sh
      find . ""*foo*""
      ```

      - First the “`.`” argument is a path that tells `find` where to start the search; in this case it's the current working directory. (Remember the dot is shorthand for the directory where you are. We could also give a relative path like “`bar`” or an absolute path from the root “`/`”. Wherever you’d like to search from.)
      - Second, we provide an expression for a filename. Here we’ve provided a glob pattern, “`*foo*`”. The `*`s on either side mean that we want everything with `foo` in the name, regardless of what is around it. The `*` can be any string, including an empty string, so “`foo`”, “`myfoo`”, “`foobar`” and “`space food vendors.txt`” would all be valid matches.

      Maybe you noticed on the `man` page - `find` has lots of options. Many of them are related to how the search is performed and reported.

      `find` additionally takes special kinds of arguments that it calls “*expressions*”. These expressions are specific to `find`, but they might look like command options at first glance.

      For more information on everything possible, take a look at `man find` and begin by searching for the “`EXAMPLES`” section near the bottom of the page, or checking the definition of *expressions* (which are collections of “*primaries*” and “*operands*”).

  
  Reading10: &reading10
    type: reading
    content: |
      # File Manipulation
      So far we’ve looked at commands that browse and alter the filesystem, where data is saved. Next we’ll introduce some command line programs for reading and writing the data inside files, as well as some shell features that give us greater power over storing and manipulating that data.

      ## Commands

      First we’ll take a look at some of the essential commands. Another term for CLI commands is “*utilities*” - you may have seen it used already in the `man` pages.

      ### `cat`

      Let's learn a new command, `cat`. `cat` prints out the text from a file.

      `cat` is short for “con**cat**enate”, which means “to connect, join or arrange”. If given more than one file argument, `cat` will print out each one in the order they’re specified, joining them (on the printed output, at least).
      
      Try it out by reading any of the many .txt files around your home directory (be careful! some may only be pretending to be .txt files)
      
      ### `touch`

      “`touch`” is a command that "*touches*" a file. If the file exists `touch` updates its modified date. If the file does not exist, then an empty file will be created at that location.

      Make sure you’re in your home directory. Use `pwd` to check and `cd` if you need to change directories.



      Now try:

      ```sh
      touch foo
      ls -l
      ```

      You’ll see that there’s a new file named “`foo`”. You can see from `ls` the file is very small - is it really empty? `cat foo` to print its contents if you want to check. Even when a file is empty, it takes a little bit of data to note the existence of the file itself.

      Notice there’s another file already in your home directory, “`bar`”. Check its contents - it’s not empty. Then: 

      ```sh
      touch bar
      ls -l
      ```

      The modification date of “`bar`” has now changed. But you can see that the contents have not changed - it’s not a new file.

      Why is this useful? There are many other ways to create new files, particularly when saving new data from other programs. But `touch` may be convenient when you only need an empty file.

      Then, why does it change the modification date? This is because `touch` is actually more often used as a scripting tool, when processing and organizing files for larger tasks. You may not need to `touch` files manually very often, but chances are you’ll come across its use in a script.

      ### `echo`

      `echo` is a simple and versatile command. It can evaluate an expression and write it to the terminal standard output (STDOUT, which we'll explain further below). You can use this in many different ways. A simple example is where the expression is a string literal.

      If you type:

      ```sh
      [username]@[host]$ echo "This is echoed"
      This is echoed
      ```
      You will see that it was repeated back to you.

      Now type:

      ```sh
      echo ~
      ```

      The shell performs substitutions and expansions for you, so what you get back is your home path, thanks to *tilde expansion*. `echo` is convenient for printing the results of stuff you can do with shell language substitutions.

      ### `md5sum`

      “`md5sum`” is way to determine whether a file has been modified. 

      This is the “*integrity*” property.

      Since it is only a function of the file contents, it can also be used to check whether two files have the same contents. 

      `md5sum` is called a “*cryptographic hash function*”. A “*hash function*” maps a large, possibly infinite set of values (in this case, all possible file contents) to a smaller set of values of a fixed size (here, 128 bits). A *cryptographic* hash function does so in such a way that it is hard to construct an input that maps to a given output - thus it is not easy to infer the content of the file just by its MD5 hash.

      This category of functions also includes SHA256 and others in the SHA family. Cryptographic hash functions and their hash values are also sometimes called “*checksums*”, but the two terms are not identical. Used in specific senses, checksums pertain to transmission errors, whereas cryptographic hashes are about security risks.

      

  
  Reading11: &reading11
    type: reading
    content: |
      # Pagers and Editors
      ## Pager Utilities

      “*Pagers*” are a group of command line utilities that allows users to view text one page at a time. This is particularly useful when dealing with output that is too large to fit on a single screen, as it prevents the information from scrolling past too quickly to read.

      The most commonly used pagers in Unix-like systems are “`less`”, “`more`” and “`tail`”.

      Pagers give you an adjustable view of a file like a text editor, but pagers are read-only - you cannot edit the file while viewing it.

      ### `less`

      The command “`less`” is used to open larger files, page by page. It allows you more tools to read a file in an organized fashion than you might have just by scrolling through your terminal output.

      `less` and other "pager" programs like it date back to time when memory for terminal scrollback was limited or not available at all. `less` remains a useful tool when working with files on the command line.

      It happens that many of its advanced search features are similar to those found in common Unix text editors, which we’ll introduce shortly.

      ### `more`

      The “`more`” command is used to view the contents of a file in a paginated manner. It allows users to scroll through the file one screen at a time, which is particularly useful for viewing large files.

      Counterintuitively, `more` actually has fewer features than `less`. `less` is a newer and more flexible pager. `more` doesn’t have search features, and can’t read a file that’s being written to at the same time. But you may see `more` because it’s included in a many system installations for compatibility.

      ### `tail`

      The “`tail`” command is used to display the last part of a file. By default, it shows the last ten lines, but you can customize its behavior using various options.

      - Custom line count: Use the `-n` option to specify the number of lines to display.
      - Real-time monitoring: With the `-f` option, `tail` can follow a file, displaying new lines as they are added. Run this way `tail` will continue even when it reaches the end of the file, waiting to print additional new lines. Press ^C to stop monitoring and return to the shell.

      `tail` is convenient when you don’t need or want to scroll manually. `less` can follow the tail of a file too, but it takes a few more keystrokes.

      `tail` can be used in many interesting ways, here are a few you might want to considering trying yourself: 

      1. Use the `tail` command to view a file, for example, `tail /var/log/syslog`.
        - Observe the last ten lines of the file.
      2. Display a custom number of lines from the end of a file.
        - Use `tail -n 20 /var/log/syslog` to display the last 20 lines of the file.
        - Experiment with different numbers to see how the output changes.
      3. Monitor a file in real-time as it updates.
        - Use `tail -f /var/log/syslog` to follow the log file in real-time.
        - In another terminal, generate some log activity (e.g., by restarting a service).
        - Observe how `tail` updates the output as new lines are added to the log file.
      4. Display the last specified number of bytes from a file.
        - Use `tail -c 100 /var/log/syslog` to display the last 100 bytes of the file.
        - Experiment with different byte counts to see how the output changes.
      5. Combine tail with other commands using pipes.
        - Use a command that generates output, such as `dmesg`, and pipe it to tail like this: `dmesg | tail -n 15`.
        - Observe the last 15 lines of the output.
        - Experiment with different commands and line counts.
      
      ## Text Editors

      There are many ways to create and modify text files on the command line. When you need all the features of an interactive text editor, there are a number of choices.

      We use the minimal editor “`nano`” for most examples in eduRange unless otherwise stated. In these exercises, `nano` is all you’ll need, but we’ll mention a few common alternatives by name so you know them when you see them.


      Often the convention in Unix-like systems is for tools to change data without asking. `nano` and other command line editors don’t change files until you save, and many of them offer conveniences like undo histories. It may seem like a small thing coming from graphical desktop environments, but editors are somewhat special in that they allow you to check your changes before committing them to disk.

      ### `nano`

      Like the name implies, “`nano`” is a small text editor. Called with no arguments, it opens an editor session for an unnamed file; when you go to save, it will allow you to specify a path to write out to. Called with an argument, `nano` attempts to open and read the file at the path provided. If no file exists, a new one will be created when saving.

      As with `man` or `less`, once `nano` starts, it is controlled differently than the shell. If you type, your text will be entered into the file to be written. Text is inserted at the blinking cursor, which can be moved around with arrow keys. At the bottom of the screen is a summary of command keystrokes. (Remember, “`^`” is shorthand for the Control key modifier.)

      The most important are:

      - `^O` to “*write **o**ut*” (when you type you’re writing to a temporary buffer; it doesn’t save to the actual file until you write out)
      - `^X` to “*e**x**it*”
      - `^G` to “***g**et help*” if you’re curious about the others

      The keystrokes are case-insensitive.

      ### `pico`

      Kind of like `less` is to `more`, `nano` is to `pico`. `pico` was developed at the University of Washington and `nano` is a clone by the GNU Project that was produced to succeed it.

      Unlike `less` and `more`, the controls and capabilities of `pico` are near identical to `nano` above.

      Originally the open source status of `pico` was unclear, and so GNU was motivated to produce `nano` as a free replacement. UW has since moved newer versions of `pico` to a different license and continued development (whereas `more` became a relic after `less` was created). Today, both `nano` and `pico` have open licenses and are commonly present together on many systems.

      ### `vim` and `vi`

      You’ll probably come across references to `vim` or its predecessor `vi`. These have powerful tools related to searching and batch editing files, but we won’t have use for those features in this exercise.

      Many power users prefer `vim` (which stands for “**`vi`** I**m**proved”) - however `vi` is more likely to be preinstalled on most Unix distributions.

      `vi` has different control modes for navigating a file as opposed to editing it, so it can be confusing for beginners. For that reason we favor `nano` here. But it’s interesting to note that the keystroke conventions for browsing files with `less` are shared by `vi` and `vim`.

      ### `emacs`

      You might also hear mention of `emacs`, another editor associated with the GNU Project. `emacs` has many features and reaches clear outside the realm of a simple text editor. If you program in other languages on the command line, you may come back to `emacs` as part of your development environment.
  
  Reading12: &reading12
    type: reading
    content: |
      # Redirection and Command Composition

      ## Input/Output Redirection

      Redirection operators - written with angle brackets like “`>`” and “`<`” - are used to write the output of a command to a file or a file to the input of a command. They have many uses.

      ((Introduce STDIN/STDOUT))

      ### Output Redirection With `>` and `>>`

      The “`>`” “*redirects output*” to a file. `<command> > <path>` will write a file to “`path`” with what is output by the “`command`” on the left hand side. If the file already exists, `>` will overwrite the file with what you sent it, in effect deleting the previous content. In contrast if you use `>>`, it will append what you sent to the end of the file, leaving the existing data intact.

      Let's give it a try. Try:

      ```sh
      echo "This is cool" > newfile
      cat newfile
      ```

      Next type:

      ```sh
      echo "This is cool too" > newfile
      cat newfile
      ```

      You can see that `>` will replace any text with what you send it, while `>>` will append to a file. Enter the following:

      ```sh
      echo "This is another thing" >> secondfile
      echo "Hello World" >> secondfile
      cat secondfile
      ```

      By using `>>`, both lines were saved to `secondfile`.

      Now let's use `>>` to combine the two files. Type:

      ```sh
      cat newfile >> secondfile
      cat secondfile
      ```

      You can see the contents of `newfile` appended to the end of `secondfile` whereas if you `cat newfile` it will still only have what we wrote to it earlier.

      ### Input Redirection With `<`

      The “`<`” operator “*redirects input*” into a command from a file - the opposite of `>`. The command still comes first, followed by the operator and then the file (input) path. A command that reads keyboard input will then receive the contents of the input file rather than interacting with your terminal session.

      Remember, `man bash` (or your particular shell) has the documentation on shell language features like redirection.

      ### Input and Output Redirection With Pipes `|`

      `<` and `>` and their relatives help get data to and from the command line to the filesystem. The “*pipe*” operator, written as “`|`”, takes the output of one command and provides it as the input to another command. This allows you to combine the functionality of two commands in a single statement, without needing to save the intermediate data to file.

      We’ll practice using pipes a lot, as they’re widely used. Before that, here’s a couple notes related to finding information on pipes.

      First, when they appear as a redirect operator, the “`|`” is usually read as “pipe”, but be aware that you may see it used as punctuation or as an operator in other languages. It can also be read as “bar” and “vertical bar” and in other languages may represent logical “or”.

      Second, there’s a related term called a “named pipe”. Named pipes are special types of files. They are also for moving data from place to place, so they’re conceptually similar to these pipes, but named pipes are not redirection operators. We won’t use them today - just don’t confuse them with redirections.

      ((Refer to relevant section of `man bash` because redirections are not a command nor sys call per se))

      TASK: There is a directory in your home called `textfiles`. Inside are three files; append them all to a new file called `alltogether.txt` in your home directory.

      ((Original question 5?: What command or list of commands did you use to create a file with the contents of the three files in the textfiles directory? (Endless approaches, this question will not be graded automatically)))

      ### Tip: Use Redirection to Filter Output Streams

      One useful trick you can do with redirection operators is suppress error messages.

      Say you have a command that produces lots of output (like searching through every sub-directory of a big directory with `find`) and sometimes that command produces errors (for instance when `find` tries to search a directory for which you don't have permissions).

      If you want to just focus on the normal output and suppress the error messages that may result, you can add '2>/dev/null' to your command. For example:

      ```sh
      find . filename 2>/dev/null
      ```

      There’s a little magic going on here. The “`2`” is short for “`STDERR`”. Like `STDIN` and `STDOUT`, `STDERR` is a sort of file that the shell and shell commands use to communicate text. Normally `STDERR` prints to the same place as `STDOUT`, but we’re sending it some place else so we don’t see it on `STDOUT` here.

      Why “`2`” instead of `STDERR`? You won’t need the details for this lesson, but the numeric representation is called a “file descriptor” and discussion can be found in `man bash` and related `man` pages.

      Similarly you won’t need to know much about the contents of `/dev` here, but for the curious, `/dev/null` is a special file that is always empty. It never changes, never stores data written to it, and contains only the end-of-file character when read. Unlike an invalid path, reading and writing to `/dev/null` always succeeds, so it’s used as a shortcut when a path is a required argument for some operation but you don’t need the results and would discard them anyways. Because it can’t be changed, `/dev/null` is a rare exception to the rule of `/dev` being a sensitive area.

  Reading17: &reading17
    type: reading
    content: |
      ## Question List

      On this tab you can find the master list of questions for this scenario.
      They will also be interleaved into the readings, but if your ever worried you missed one you can check here and it should reflect your points earned correctly.

  Reading18: &reading18
    type: reading
    content: |
      ## Filters
      
      “*Filters*” are a category of commands that take input (generally text), apply some operation to the input and then print the result back out to standard output. Some examples of operations could be sorting, searching or counting.

      ### `sort`

      The “`sort`” command is a tool that is used to **sort** lines of text. It’s handy for sorting lists that are out of order. It can sort specific columns or entire lines alphabetically, numerically, or even in reverse order.

      `sort` by default will sort the list in alphabetical order according to the first letter of each line. Lowercase characters are listed before uppercase letters.

      - The option `-r` sorts the list in reverse order.
      - The option `-n` will sort the list numerically.
      - You can sort a specific column using the option `-k` and a numeric argument.

      One use for the `sort` command is to reorder the output of a shell command, such as `ls`, through the use of a pipe.

      Task: Using `ls`, `sort`, and a pipe, organize the files in your home directory in reverse alphabetical order.

      It should look like `<source> | <filter>` where:

      - “`source`” is the `ls` output you want to `sort` and
      - “`filter`” is the `sort` command and relevant options.

      ((To add: sort a text file or piped input eg sort a table of IP addresses by a time column))

      - ((Make static file))

      ### `uniq`

      The `uniq` command is used to reduce the number of repeated lines that are printed while viewing a file, and, as a result, it is very often used with `sort` (using a pipe). It only prints the first instance of a line, and does not print repetitions of that line that follow after that instance. Though it’s called “***uniq**ue*”, `uniq` doesn’t guarantee to remove all repetitions - just those that follow one another. 

      Run on the input:

      ```sh
      A
      A
      B
      A
      A
      ```

      `uniq` alone would produce:

      ```sh
      A
      B
      A
      ```

      `uniq` only compares against the most recent line it has seen. For that reason, you’ll usually find it used in conjunction with `sort`. The syntax of the `uniq` command, used with `sort`, would look like this: `sort [file ...] | uniq`. This would give you lines *unique* to the entire file. But they must be sorted in some way, alphabetical or otherwise, so that repeated lines are all adjacent.

  Reading19: &reading19
    type: reading
    content: |
      ### grep and Regular Expressions

      The “`grep`” command has a similar use to `find`, however, instead of searching for files, `grep` searches within files for lines that contain a string you specify. Unlike the *glob patterns* used by `find`, `grep` uses a convention called *regular expressions*.

      “`grep`” stands for “**g**lobal / **r**egular **e**xpression search / and **p**rint” - originally it was a series of commands in an editor, but was so useful someone turned it into a utility of its own. The general syntax of the command is:

      `grep [pattern] [file ...]`

      Some options for `grep` include:

      - Case insensitivity (“`-i`”)
      - Only print the filename that contains the pattern (“`-l`”)
      - Print out line numbers along with the matching criteria (“`-n`”)
      - Print lines that do not match the criteria (“`-v`”).

      ((Explain regular expressions))

      #### Regular Expressions

      “*Regular expressions*” are another style of text patterns. They have similar basic uses to globs, but are much more complex and powerful. We’ll only present a few of their applications here.

      First, note that some symbols and ideas are shared between regular expressions (“*regexes*”) and glob-style patterns. The “`*`” is not a wildcard in a regex, but it does something similar; when “`*`” follows a sub-pattern in a regex, the resulting pattern matches zero or more occurrences of the sub-pattern.

      Regexes allow you to specify the number of matches separately from the expression that is matched, whereas glob wildcards do both in a single symbol. Here globs are shorter, but regexes are more flexible.
  
  Reading20: &reading20
    type: reading
    content: |
      TODO: Instructions for the final mission

  Question1: &question1
    question_num: 1
    type: question
    content: What is the full "FLAG{...}" string that is provided after ssh-ing in?
    options: []
    answers:
      - value: "FLAG{WELCOME}"
        answer_type: String
        points_possible: 15
    points_possible: 15
  Question2: &question2
    question_num: 2
    type: question
    content: Open the `man` page for `cp`. What option would provide verbose output? It’s worth noting that many commands provide an option with this name, not just `cp`.
    options: []
    answers:
      - value: "-v"
        answer_type: String
        points_possible: 15
    points_possible: 15
  Question3: &question3
    question_num: 3
    type: question
    content: How many files and directories are in your home directory? (EXCLUDING hidden files and . or ..)
    options: []
    answers:
      - value: "11"
        answer_type: String
        points_possible: 15
    points_possible: 15
  Question4: &question4
    question_num: 4
    type: question
    content: What is the name of the hidden file in your home directory that is over 1 megabyte?
    options: []
    answers:
      - value: file — determine file type
        answer_type: String
        points_possible: 15
      - value: file - determine file type
        answer_type: String
        points_possible: 15
  Question5: &question5
    question_num: 5
    type: question
    content: In your home directory there is subdirectory named followMe. Travel into the directory as far as you can go. At the end there is a file. What is the name of the file?
    options: []
    answers:
      - value: "$RANDOM"
        answer_type: String
        points_possible: 15
    points_possible: 15
  Question6: &question6
    question_num: 6
    type: question
    content: In the file-practice directory, rename file_1.txt to renamed_file1.txt and copy file2.txt to copied_file2.txt. What is the output of 'wrangle_flag' if you run it as a command?
    options: []
    answers:
      - value: "FLAG{WR4NGL3R}"
        answer_type: Essay
        points_possible: 15
    points_possible: 15
  Question7: &question7
    question_num: 7
    type: question
    content: Use chmod to make 'you_cant_read_me.txt' in your home directory readable. What is the flag it contains?
    options: []
    answers: 
      - value: "$RANDOM"
      - answer_type: String
      - points_possible: 10
    points_possible: 10
  Question8: &question8
    question_num: 8
    type: question
    content: In the multimedia-content directory, which file is actually an OpenSSH RSA public key?
    options: []
    answers: 
      - value: "staff_schedule2.docx"
      - answer_type: String
      - points_possible: 10
    points_possible: 10
  Question9: &question9
    question_num: 9
    type: question
    content: |
      What are the filenames (with extensions) of the six image files hidden somewhere within your home directory that contain top_secret in their name? 
      Please enter the filesnames as a comma separated list, e.g. ("file1.jpg, file2.png, file3.gif").
    options: []
    answers:
      - value: 4top_secret.jpg
        answer_type: String
        points_possible: 3
      - value: do_not_share_top_secret.png
        answer_type: String
        points_possible: 3
      - value: still_top_secret.gif
        answer_type: String
        points_possible: 3
      - value: top_secret002.jpg
        answer_type: String
        points_possible: 3
      - value: top_secret3.GIF
        answer_type: String
        points_possible: 3
      - value: top_secret5meow.JPG
        answer_type: String
        points_possible: 3
    points_possible: 18
  Question10: &question10
    question_num: 10
    type: question
    content: What is the very first line of "comms_record.txt" in your home directory?
    options: []
    answers:
      - value: "Begin Nav Check: Z94732"
        answer_type: String
        points_possible: 20
    points_possible: 20
  Question11: &question11
    question_num: 11
    type: question
    content: What is the very last line of "comms_record.txt" in your home directory?
    options: []
    answers:
      - value: "Date: 8764.56.14"
        answer_type: String
        points_possible: 20
    points_possible: 20
  Question12: &question12
    question_num: 12
    type: question
    content: What is the numerical value of the first "Quantity" listed when sorting the "cargo_manifest.txt" in your home directory alphabetically?
    options: []
    answers: 
      - value: "100"
      - answer_type: String
      - points_possible: 10
    points_possible: 10
  Question13: &question13
    question_num: 13
    type: question
    content: How many unique jobs are available on the ship according to "assignments.txt" - Remember that `uniq` requires sorted input.
    options: []
    answers:
      - value: "13"
      - answer_type: String
      - points_possible: 10
    points_possible: 10
  Question14: &question14
    question_num: 14
    type: question
    content: How many unique *Sender* ip addresses are in radio_logs.txt?
    options: []
    answers:
      - value: "24"
      - answer_type: String
      - points_possible: 20
    points_possible: 20
  Question15: &question15
    question_num: 15
    type: question
    content: |
      Somewhere on your system outside of your home directory, there is suspected to be a secret file. It contains "shad0w_syn" in its name. 
      what is the full absolute path to the directory it is in? (Just the directory, don't include the filename)
    options: []
    answers:
      - value: "/usr/special/secrets/uncategorized/"
      - answer_type: String
      - points_possible: 15
    points_possible: 15
  Question16: &question16
    question_num: 16
    type: question
    content: |
      In the "permit_request" directory in your home directory, which file has an md5sum hash that begins with "c3c9" and ends with "e3e3"?:
    options: []
    answers:
      - value: "req9A323.txt"
      - answer_type: String
      - points_possible: 20
    points_possible: 20


# Order of content using aliases
studentGuide:
  chapters:
    - chapter_num: 1
      title: Welcome to Cybersec
      content_array:
        - *reading1
        - *reading2
    - chapter_num: 2
      title: Questions
      content_array:
        - *reading17
        - *question1
        - *question2
        - *question3
        - *question4
        - *question5
        - *question6
        - *question7
        - *question8
        - *question9
        - *question16
        - *question10
        - *question11
        - *question12
        - *question13
        - *question14
        - *question15
    - chapter_num: 3
      title: Man Pages
      content_array:
        - *question1
        - *reading13
        - *question2
        - *reading3
    - chapter_num: 4
      title: Filesystem
      content_array:
        - *reading4
        - *question4
        - *reading14
    - chapter_num: 5
      title: Commands and Navigation
      content_array:
        - *reading6
        - *question3
        - *question4
        - *reading15
        - *question5
        - *reading7
        - *question6
    - chapter_num: 6
      title: Permissions (chmod and sudo)
      content_array:
        - *reading8
        - *question7
    - chapter_num: 7
      title: Find and File
      content_array:
        - *reading9
        - *question8
        - *reading16
        - *question9
    - chapter_num: 8
      title: File Manipulation
      content_array:
        - *reading10
        - *question16
    - chapter_num: 9
      title: Pagers
      content_array:
        - *reading11
        - *question10
        - *question11
    - chapter_num: 10
      title: Redirection
      content_array:
        - *reading12
    - chapter_num: 11
      title: Filters, Grep, and Regex
      content_array:
        - *reading18
        - *question12
        - *question13
        - *reading19
        - *question14
    - chapter_num: 12
      title: Finale
      content_array:
        - *reading20
        - *question15
